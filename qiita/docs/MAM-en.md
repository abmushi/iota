Deep Dive into MAM: the IoT-ic feature of IOTA

# Preface
 MAM(Masked Authenticated Message) is one of the Beta service but must call more attentions from developers. Currently, IOTA officially is developing the newest version of MAM at [here](https://github.com/iotaledger/MAM) in Rust. However, this article explains the older and deprecated version of MAM written in [Javascript](https://github.com/iotaledger/mam.client.js). Since the big picture and algorithm used in both version are quite similar and considerring there are few articles available online that disclose the blackbox behind what MAM does, I think the deprecated explanation of MAM is still usefull for many potential developers to understand MAM and widen the visible frontier. 

# MAM
 IOTA boasts of its zero transaction fee. Also, each transaction object could contain a **signatureFragment** of 2187 length. MAM's first basic idea is that by encrypting the signatureFragment, one could easily claim cloud storage on Tangle, which in MAM is called **Channel**. And key that encrypts and decrypts it is called **Channel Key**. If you want to publish your channel available to public, you could just make your Channel Key public. If not, let it hide and never tell anybodies. The Channel Key can be chosen by channel owner arbitrarly.
 
 Publicized message on channel is stored at the address on the Tangle. Like you search your address balance in [Tangle Explorer](https://iotasear.ch/), you can read your encrypted message there. With corresponding Channel Key, you can understand it.

## MAM summary
 MAM is often said to be like a radio, where Only who knows the radio frequency may reach the message. In MAM, only who knows the Channel Key can view the message.
> Major points
>1. **Encrypting** raw message with Channel Key.
>2. Only who knows **Channel Key** can decrypt message.
>3. Knowing the Channel Key is not enough to be a Channel owner. To publicize message on channel, you need channel owner's seed.
>4. From older to newer, the message is stored in the form of the chain generated chronologically. And the message chain may fork.
>5. If you join the channel message chain at some point, you cannot look back to see the past message.

Detail will be explained later.

### In Practice
主な利用例として考えられるのが、例えば
>1. **IoTのデータ管理**：工場内のデバイスやセンサー群から集まった秘匿にしたい数値を暗号化してチャンネルに投稿し、担当者のみがもつChannel Keyでデータにアクセスする。生データの秘匿性を確保しつつ公開台帳に情報を保持できる。
>2. **グループチャット**：Channel Keyを教え合って２つ以上のチャンネル間をまたいでチャットする。（非公式Alpha版[iota1k](https://github.com/xx10t4/iota1k)が有志によって開発されている。）

## Older MAM and Newer MAM
 As I notified above. This article explains the older MAM. But, for those who are interested in newer, jump to this [link](https://blog.iota.org/introducing-masked-authenticated-messaging-e55c1822d50e).
 
# MAM Implimentation
　Take a quick look at the example codes from [github](https://github.com/iotaledger/mam.client.js).
## Publish MAM - post.js
source [here](https://github.com/iotaledger/mam.client.js/blob/master/examples/post.js).

```js:post.js
const IOTA = require('iota.lib.js');
const MAM = require('../lib/mam');
const MerkleTree = require('../lib/merkle');
const Encryption = require('../lib/encryption');
var Crypto = require('iota.crypto.js');

const iota = new IOTA({
  provider: 'http://localhost:14600'
});

// your seed as a publisher
const seed = 'PAUL9NOZTUVHPBKLTFVRJZTOPODGTYHRUIACDYDKRNAQMCUZGNWMDSDZMPWHKQINYFPYTIEDSZ9EJZYOD';

// raw message you want to post 
const message = "\"'I'm still here for IOTA in the same way that you're here for me, each person is an intricate piece of infinity. -Eyedea\" - Dukakis";

// generate your Channel Key
// in this example is generated by hashing the seed.
// But, you could choose any arbitrary channel key. 
const channelKeyIndex = 3;
const channelKey = Crypto.converter.trytes(Encryption.hash(Encryption.increment(Crypto.converter.trits(seed.slice()))));

//  Merkle Tree attributes (explained later)
const start = 3;
const count = 4;    // Merkle Treeのsize
const security = 1;

//  Merkle Tree generation
const tree0 = new MerkleTree(seed, start, count, security);
const tree1 = new MerkleTree(seed, start + count, count, security);
let index = 0;

//  create bundle necessary for publishing your message to the Tangle.
const mam = new MAM.create({
    message: iota.utils.toTrytes(message),  // convert you raw message to trytes here.
    merkleTree: tree0,
    index: index,
    nextRoot: tree1.root.hash.toString(),
    channelKey: channelKey,
});

// Depth
const depth = 4;

// minWeighMagnitude
const minWeightMagnitude = 13;

console.log("Next Key: " + mam.nextKey);

// Send trytes（attach your Bundle to Tangle）
iota.api.sendTrytes(mam.trytes, depth, minWeightMagnitude, (err, tx) => {
  if (err)
    console.log(err);
  else
    console.log(tx);
});

```
## View message - getMessage.js
source [here](https://github.com/iotaledger/mam.client.js/blob/master/examples/getMessage.js).

```js:getMessage.js
const IOTA = require('iota.lib.js');
const MAM = require('../lib/mam');
const MerkleTree = require('../lib/merkle');
const Encryption = require('../lib/encryption');
var Crypto = require('iota.crypto.js');

const iota = new IOTA({
  provider: 'http://localhost:14600'
});

//  シード
const seed = 'PAUL9NOZTUVHPBKLTFVRJZTOPODGTYHRUIACDYDKRNAQMCUZGNWMDSDZMPWHKQINYFPYTIEDSZ9EJZYOD';
const channelKeyIndex = 3;

//  generating Channel Key of the channel you want to view.
//  When viewing someone else's channel, substitute given Channel Key here.
const channelKey = Crypto.converter.trytes(Encryption.hash(Encryption.increment(Crypto.converter.trits(seed.slice()))));

//  Merkle Tree attributes.
//  When viewing someone else's channel, substituting given root here.
//  explained later.
const start = 3;
const count = 4;    // size of Merkle Tree
const security = 1;

//  Merkle Tree generation
const tree0 = new MerkleTree(seed, start, count, security);

//  get the root
const root = tree0.root.hash.toString();



iota.api.sendCommand({
    command: "MAM.getMessage",
    channel: MAM.messageID(channelKey)
}, function(e, result) {
    if(e == undefined) {
        result.ixi.map(mam => {
            const output = MAM.parse({key: channelKey, message: mam.message, tag: mam.tag});
            const asciiMessage = iota.utils.fromTrytes(output.message);
            if (root === output.root) {
                console.log("Public key match for " + root);
            }
            console.log("received: " + asciiMessage);
        });

    }
});

```
# Behind MAM - Overview
## Channel Key - `channelKey`
　`chennelKey` is an arbitrary 81 trytes, like seed. First of all, publisher publish first `message`. The `message` is encrypted with the `channelKey`. In this way, no one other than this publisher can understand the `message`.

![mam_channelKey_basic.png](https://qiita-image-store.s3.amazonaws.com/0/187795/1459dbff-a02b-fc6c-bdb9-1caaa89844c7.png)

　However, in this way, you can only publish message once on your channel. In other words, one 'channelKey' can reach only one message. If you post new message on the channel, whenever you do so, you have to tell your viewer the new Channel Key. And you have to store all channel key safely and keep track of them which to which. It can be a mess.

## Image of Solution
　Let me explain to you with easy image for now. That might ignore small negligible details. (Don't worry for those with interests in minute detail, I will eventually explain.)
### Next Channel Key - `nextChannelKey`
　Before encrypting your raw message, MAM includes the **next channel key(`nextChannelKey`)** in your message to be encrypted. If to say in RPG, in the first treasure chest you opened, it's like you would find the key that opens next treasure chest. By repeating this can viewers sequently decrypt next `message` with `nextChannelKey` you obtained from current `message` you have just decrypted. And publisher can give `nextChannelKey` of any points on the channel. That way, you can restrict viewers from viewing the past messages.
 \*`nextChannelKey` can be arbitrary 81 trytes.

![mam_nextKey_1.png](https://qiita-image-store.s3.amazonaws.com/0/187795/035bba8e-d285-3a61-265d-f3fcf9e1b5fc.png)

### Address of the message - `messageID`
　You might have ever noticed, you have your key but don't have the map that guides you to the treasure chest. In technical term, having `channelKey` or `nextChannelKey` is no use to find where the message is stored. 
 In MAM, the address where the message is stored is called `messageID`. And it is simply generated by hashing `channelKey` or `nextChannelKey` twice. The  treasure map is drawn on the key. Just having your key is suffucient for both finding and decrpting message.

![mam_messageID1.png](https://qiita-image-store.s3.amazonaws.com/0/187795/24322eb3-93d4-b82e-2afd-4d9fd58ae6eb.png)

\* The way to generate `messageID` is arbitrary as long as you and potential viewers share how to. But, at least you should hash it to protect your key.

### Message Chain
　The genesis `message` that contains raw message and `nextChannelKey` of the channel encrypted with `channelKey` will be a part of the bundle. And the bundle that contain next `message` is pointed by the previous bundle. By repeating this, you can now see a chain on the Tangle, **Message Chain**. You can join message chain at any points with corresponding key to decrypt it, but never can go back to see past posts.

## Implimentaion in Practice
 Now the time to see what's in practice. Reality is always somewhat different than blueprint.
 At first, it is costly to encryt `message` to get `nextChannelKey`. If you are interested in the newest post of the channel, but only to realize it has hundreds of the previous posts. Decrypting all of them just to view one last post is not realistically feasible. So, in practice, instead of having `nextChannelKey` encrypted IN the `message` with raw message, `nextChannelKey` is generated by the formula `nextChannelKey = hash(channelKey + salt)` ,where `salt` is an arbitrary `tag` of the Transaction object chosen when posting the message. Since the `tag` is a part of the Transaction object, to know `tag` you need `messageID`(address) the transaction is stored. And the transaction can be found only with `channelKey`. Note that this way still holds MAM's restriction, only who knows `channelKey` can know `nextChannelKey`.
 
　If to say in the treasure chest analogy, next key is not in the chest, but attached to the surface of the chest. But, only who brought the key can see the next key.
 
![mam_next_key_tx.png](https://qiita-image-store.s3.amazonaws.com/0/187795/af4df8f3-9a12-e897-4d47-a247be596586.png)

　Moreover, if the `message` exceeds the capacity(2187 trytes) of the `signatureFragment` of the Transaction, you don't need to make two different MAM messages and post twice as two messages on the message chain. You can just increase the number of transactions stored in the bundle and attach the bundle with long message as one MAM message. But, too long bundle may require too heavy PoW to attach it to the Tangle and it's also costly when retrieve it from the Tangle.
 
# Behind MAM - Publishing
　Now I'm going to talk about the forgotten aspect of the MAM, Channel's ownership. Let's take a look at the case below.

 Alice has just published her first message on her channel and want Bob to read her post. So, Alice gave him her `channelKey`. Bob visited her message by generating address(=`messageID`) and decrypt it with `channelKey`. Bob enjoyed her post and thought "wanna read next!". And he has `nextChannelKey` in the decrypted current message, and can generate next address out of it. But, he realized that Alice hasn't published next message yet, at next `messageID`, there're no transactions made.
 Bob suddenly became evil. He has `nextChannelKey` and next `messageID`. He can post his message encrypted with `nextChannelKey` to the address `messageID`. And he could hijack Alice's channel.
 Do you think it would work? From information explained so far, there's no contradiction.
...However, that's MAM's failure. Don't worry, MAM is designed so people like Bob cannot jumble up the channel. Next topic to cover is how Alice keeps her message chain from being edited by anyone else.

## Channel's ownnership
　The problems mentioned above could simply be summarized as:**Chennel Key implimentation cannot identify who of Alice and Bob owns messages.**
　Now recall how the address of IOTA is signed by its proper owner.ここでIOTAにおける、アドレスの残高の所有権はどう証明したかを思い出してみよう。アドレスの残高を引き出す際には、Seedから生成される**Private Key**で[署名](https://qiita.com/ABmushi/items/422d1bf94be0c919583a#%E7%BD%B2%E5%90%8D%E3%81%AE%E6%96%B9%E6%B3%95)したトランザクションが承認されることで残高を引き出すことができた。
　MAM uses technic that utilizes both Private Key and Merkle Tree scheme to prove ownership of the channel.

## Merkle tree based signature scheme 
　[Merkle tree based signature scheme](https://www.imperialviolet.org/2013/07/18/hashsig.html) is the technic used in MAM.
　But, I don't explain what the computer science term "Merkle Tree" is. Because since interests in Cryptos skyrocket, the idea of the merkle tree, which is the core module often seen in plenty of cryoto projects, is explained countless times at various places. You could just google it.
 
### Merkle Treeの生成
Source [here](https://github.com/iotaledger/mam.client.js/blob/master/lib/merkle.js#L54)
Merkle Tree of MAM is generated from seed. (What a surprise that seed grows up to a tree!) Merkle Tree has two parameters, `start` and `size`. `start` is used as a parameter `index` of creating private key. And `size` is used to specify the range in the sequence of the private key generation. To illustrate, look at the figure below. A,B,C,D are the private keys generated with `index` parameters as 0,1,2,3(where `start = 0`). And A',B',C',D' are the address generated out of each private key.

![mam_merkle_1-2.png](https://qiita-image-store.s3.amazonaws.com/0/187795/06ea21b7-6427-90b4-1c82-4a64c53a0df1.png)

　Leaf of the merkle tree, A",B",C",D" are `=hash(address)`. From leaf to root, hash of children nodes are merged into their parent node. Obviously, you cannot generate children nodes from parent.

### Siblings
　Let's say, leaf `A'` is given, to obtain root, you need to have all other leaves `B'C'D'`. But, if you cannot access to those, how do you get root? **Siblings** are the complimentary hashes that are necessary to generate `root` with given leaf. Look at the figure below.
 
![mam_2_siblings_2.png](https://qiita-image-store.s3.amazonaws.com/0/187795/c3f7d1b4-984b-d4a1-d054-e788fe2a7a10.png)

　For the case leaf is `A'`, siblings are `B"`and `Hash(C"D")`. Without knowing all leaves, with siblings, you can calculate `root`.

### Secret Key and Public Key
　Publisher(Seed owner) has to make Private Keys, A,B,C,D confidential. But, `root` and `siblings` are public keys, because you can still achieve your private key's safety. Because, only the seed owner, or to say Merkle Tree owner, can calculate `root` from public information. Other cannot generate `root`. Yes, they know what the `root` is, but they don't know how to generate. To illustrate, using the example above, other people must have a **leaf `A'`** to generate `root` by combining it with also public `siblings`. This way, you can distinguish correct owner of the merkle tree from other folks.
 
　![mam_2_merkle_pubkey.png](https://qiita-image-store.s3.amazonaws.com/0/187795/42e5b069-c3bf-333e-2d9f-84b7fa916bcb.png)
　
　This technic is magically used in MAM to prove ownership of the message chain.

# Behind MAM - Signature and Approval
　In this chapter, I'm going to merge two major topics discussed so far:
>1. Message Chain connected via nextChannelKey
>2. Merkle Tree

## MAM.create
source [here](https://github.com/iotaledger/mam.client.js/blob/master/lib/mam.js#L63)
　Alice opens Channel. Alice then has to:
>1. generate `channelKey`.
>2. generate two Merkle Trees of same `size`. The first one starts with the index `start`.

　The first tree namely `tree0`, has `start0 = start`,`size0 = size`. Second tree `tree1` starts with `start1 = srart0 + size0`, `size1 - size0`. Second tree uses next sequence of the private keys. Figure below.
 
![mam_2_double_merkle.png](https://qiita-image-store.s3.amazonaws.com/0/187795/67d5fc56-b28f-4d91-65c5-9a56b416d240.png)
　
  When creating MAM,`tree0` itself and the root of `tree1`, namely `root_1`(**nextRoot**) is one of the parameters. And **leaf index** is chosen from **0 < i <size**. Let's say in this case, `leaf_index = 0`. Leaf index of the merkle tree is the distance from the most left leaf. leaf_index '0' of `tree0` is `A'`, leaf_index `2` of `tree1` is `G'`.
  
```java:example of MAM.create
leaf_index = 0    // leaf index

const mam = new MAM.create({
    message: iota.utils.toTrytes(message),  // convert raw message to tryte
    merkleTree: tree0,                      // the first merkle tree
    index: leaf_index,                      // leaf index
    nextRoot: tree1.root.hash.toString(),   // next root. root_1 above.
    channelKey: channelKey,                 // ChannelKey, used to encrypt this whole message.
});
```
 So, what's going to happen in MAM.create then?
　まず、`tree0`の**Siblings**を求める。今回与えられる葉は先ほど決めた**葉番号**の葉とする。ということは`leaf_index = 0`なので`siblings`は`B"`と`Hash(C"D")`になる。
![mam_2_small_sib.png](https://qiita-image-store.s3.amazonaws.com/0/187795/d67e16e9-7ad9-d54e-4ba6-978af070fc0d.png)
　次に、`messageTrytes`と呼ばれる**「nextRootと平文を足した文字列」**を署名されるデータとして**葉番号のPrivate Key**で署名を作る。署名作成については[こちら](https://qiita.com/ABmushi/items/422d1bf94be0c919583a#%E7%BD%B2%E5%90%8D%E3%81%AE%E6%96%B9%E6%B3%95)でも説明したが、それを踏まえて下図のように署名は作られる。
![mam_2_sig2.png](https://qiita-image-store.s3.amazonaws.com/0/187795/5c4af53b-d673-6e3b-b71b-ee9778df1335.png)
　こうして今、手元にある値を使ってMAMの１つのメッセージは作られる。それを図示すると下のようになる。
![mam_2_overview_single.png](https://qiita-image-store.s3.amazonaws.com/0/187795/bc220ff5-85ff-8cfe-2fac-0cadf57b32d1.png)
## MAMメッセージ閲覧 - MAM.parse
[ソースコード](https://github.com/iotaledger/mam.client.js/blob/master/lib/mam.js#L131)
　次に投稿されたメッセージを閲覧する方法について説明する。これを読むことで今まで出てきた話がついに一つにまとまる。
### チャンネル鍵と**root**を閲覧者に教える
>**チャンネル鍵**はメッセージの復号のための鍵、`messageID`（アドレス）として閲覧者に教える。そして、メッセージがAさんのものだと照らし合わせるための勘合として**`root`**を閲覧者に渡す。

　この例だと、チャンネル鍵と`tree0`の`root_0`を閲覧者にチャンネル鍵として渡す。ここでBさんが閲覧者としてAさんからチャンネル鍵とrootを教えてもらったとしよう。
　Bさんはチャンネル鍵からメッセージの保管アドレス`messageID`を作ってメッセージを見つける。そして、チャンネル鍵でメッセージを復号する。
　次に、復号したメッセージの署名を`messageTrytes`（署名されるデータ）で承認する。署名の承認の仕方は[こちら](https://qiita.com/ABmushi/items/422d1bf94be0c919583a#%E6%89%BF%E8%AA%8D%E3%81%AE%E6%96%B9%E6%B3%95%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%81%AE%E9%80%86%E7%94%9F%E6%88%90)。

　![mam_2_sig_address.png](https://qiita-image-store.s3.amazonaws.com/0/187795/464abb92-1775-8faa-8870-bf8e86fe2df9.png)
### 本人のメッセージか検証
　次に、承認して得られたアドレスが`leaf_index`の場所のアドレスとして`Siblings`を使ってその`root`を求める。こうして求められた`root`（下図のroot_0）がAさんからもらった`root`と一致すれば、メッセージはAさんのものだと閲覧者は判断できる。
![mam_2_address_merkle.png](https://qiita-image-store.s3.amazonaws.com/0/187795/052d06e5-640a-6c12-5467-df1751d0a1db.png)
　そうでない場合はどういうことか。署名を承認する時に使う`messageTrytes`の内容がAさんが作ったものと違う場合、得られるアドレスが変わる。そのアドレスと`Siblings`を使ってrootを求めると、もちろん得られる`root`の値も変わる。そして、Aさんから教えてもらった`root`と一致しない。
　こうすることで、もし悪意ある者がチャンネル鍵を使って同じ`messageID`（アドレス）宛に全くAさんと関係のないメッセージを投稿したとしても、このrootの検証作業で最終的に弾かれる。

## メッセージチェーンの構築 - nextRoot
　MAMはメッセージチェーンだ。一つのメッセージを復号すれば、`nextChannelKey`を使って次のメッセージも閲覧できる。ということは、その次のメッセージがチャンネル所有者本人が投稿したものか検証する必要がある。そのため、メッセージには`nextChannelKey`の他に、`nextRoot`という値も含ませる。この`nextRoot`は`messageTrytes`に平文と一緒に含まれているため署名されるデータの一部である。`nextRoot`生成するたびに、上の図で言う所のMerkle rootの生成に使われる葉（ABCDEF...）が右にどんどんずれていく。（`start`が大きくなっていく。）
　次の投稿を`nextChannelKey`で復号した際には、前項で説明したように今度は`nextRoot`と最終的に得られる`root`と一致するかを確認する。

## 小休止
　理解できただろうか？想像以上に多くのアイデアが詰め込まれていたことに驚いたかもしれない。筆者も文でうまく説明できたか不安だ。
　不明点等あれば公式Slackで筆者@abmushi宛にDMでもチャットでも良いので質問をじゃんじゃん投げて欲しい。質疑応答はお互いの理解が深まる絶好のチャンスだ。

# チェーンフォーク - 分裂
　最後にMAMを特徴づける**分裂**という機能についても説明したい。ブロックチェーンのようにメッセージチェーンもフォークする。
　メッセージを分裂させたいときは、単純に葉番号`leaf_index`が違う`siblings`を含むメッセージを投稿すれば良い。こうすることで同じ`messageID`（アドレス）に本人検証も問題なくできるメッセージを複数（最大はMerkle Treeの`size`）持てる。
　また、`nextChannelKey`の生成方法も（nextChannelKey=hash(channelKey,leaf_index)）というように`leaf_index`に依存するようにすれば、フォーク後全く違うアドレスを辿るようにチェーンを伸びていかせることもできる。

## 利用例
　筆者が思いついたこのチェーンフォークの用途は、MAMのメッセージチェーン自体をディレクトリのツリー構造として利用すること。
　まず最初にルートディレクトリを投稿する。そのディレクトリの子ディレクトリの数だけ分裂させることを繰り返せば、Tangle上にツリー構造を作れる。また、どの部分のチャンネル鍵を教えるかによってファイルのアクセス権限も持たせることができる。

# MAMとはプロトコル
　MAMとはそれ自体が発行者が自由に決められるプロトコルである。投稿者と潜在的な閲覧者の間でMAMの各種値（`nextChannelKey`、`messageID`、や`nextRoom`）の計算方法を統一することで、この記事で紹介した方法以外の手順を使ってMAMを発行できる。

# 最後に
　MAMを理解したいという気持ちはずっと持っていたものの、今IOTAが取り組んでいる課題は別のところにあり、コミュニティで具体的にはほとんど語られず、ビジョンとしてのみ存在していたこのMAM。結局公式のソースコードを読んで自分で理解するしか手段がなかった。
　その結果、IOTAのBundleや署名などの根幹技術がコードレベルでどうなっているか理解できたので結果的にはものすごくためになった。
　記事中でも今まで投稿したIOTAの記事の知識が前提になることが多く数え切れないほど引用リンクを貼った。間違いなくこの記事は今年の集大成だろう。
　それではみなさん良いお年を！

# 参考文献
JSのコード：[mam.client.js](https://github.com/iotaledger/mam.client.js)
公式アナウンス：[Introducing Masked Authenticated Messaging](https://blog.iota.org/introducing-masked-authenticated-messaging-e55c1822d50e)
外観：[Overview](https://github.com/iotaledger/mam.client.js/blob/master/Overview.md)
たまたま見つけた中国語の記事：[MAM　筆記](https://hackmd.io/c/rkpoORY4W/%2Fs%2FrJkpIrrbM)
