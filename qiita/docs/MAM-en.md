Deep Dive into MAM: the IoT-ic feature of IOTA

# Preface
 MAM(Masked Authenticated Message) is the function under development. Currently, IOTA officially is developing the newest version of MAM at [here](https://github.com/iotaledger/MAM) in Rust. However, this article explains the older and deprecated version of MAM written in [Javascript](https://github.com/iotaledger/mam.client.js). Since the big picture and algorithm used in both version are quite similar and considerring there are few articles available online that disclose the blackbox behind what MAM does, I think the deprecated explanation of MAM is still usefull for many potential developers to understand MAM and widen the visible frontier. 

# MAM
 IOTA boasts of its zero transaction fee. Also, each transaction object could contain a **signatureFragment** of 2187 length. MAM's first basic idea is that by encrypting the signatureFragment, one could easily claim cloud storage on Tangle, which in MAM is called **Channel**. And key that encrypts and decrypts it is called **Channel Key**. If you want to publish your channel available to public, you could just make your Channel Key public. If not, let it hide and never tell anybodies. The Channel Key can be chosen by channel owner arbitrarly.
 
 Publicized message on channel is stored at the address on the Tangle. Like you search your address balance in [Tangle Explorer](https://iotasear.ch/), you can read your encrypted message there. With corresponding Channel Key, you can understand it.

## MAM summary
 MAM is often said to be like a radio, where Only who knows the radio frequency may reach the message. In MAM, only who knows the Channel Key can view the message.
> Major points
>1. **Encrypting** raw message with Channel Key.
>2. Only who knows **Channel Key** can decrypt message.
>3. Knowing the Channel Key is not enough to be a Channel owner. To publicize message on channel, you need channel owner's seed.
>4. From older to newer, the message is stored in the form of the chain generated chronologically. And the message chain may fork.
>5. If you join the channel message chain at some point, you cannot look back to see the past message.

Detail will be explained later.

### In Practice
主な利用例として考えられるのが、例えば
>1. **IoTのデータ管理**：工場内のデバイスやセンサー群から集まった秘匿にしたい数値を暗号化してチャンネルに投稿し、担当者のみがもつChannel Keyでデータにアクセスする。生データの秘匿性を確保しつつ公開台帳に情報を保持できる。
>2. **グループチャット**：Channel Keyを教え合って２つ以上のチャンネル間をまたいでチャットする。（非公式Alpha版[iota1k](https://github.com/xx10t4/iota1k)が有志によって開発されている。）

## Older MAM and Newer MAM
 As I notified above. This article explains the older MAM. But, for those who are interested in newer, jump to this [link](https://blog.iota.org/introducing-masked-authenticated-messaging-e55c1822d50e).
 
# MAM Implimentation
　Take a quick look at the example codes from [github](https://github.com/iotaledger/mam.client.js).
## Publish MAM - post.js
source [here](https://github.com/iotaledger/mam.client.js/blob/master/examples/post.js).

```js:post.js
const IOTA = require('iota.lib.js');
const MAM = require('../lib/mam');
const MerkleTree = require('../lib/merkle');
const Encryption = require('../lib/encryption');
var Crypto = require('iota.crypto.js');

const iota = new IOTA({
  provider: 'http://localhost:14600'
});

// your seed as a publisher
const seed = 'PAUL9NOZTUVHPBKLTFVRJZTOPODGTYHRUIACDYDKRNAQMCUZGNWMDSDZMPWHKQINYFPYTIEDSZ9EJZYOD';

// raw message you want to post 
const message = "\"'I'm still here for IOTA in the same way that you're here for me, each person is an intricate piece of infinity. -Eyedea\" - Dukakis";

// generate your Channel Key
// in this example is generated by hashing the seed.
// But, you could choose any arbitrary channel key. 
const channelKeyIndex = 3;
const channelKey = Crypto.converter.trytes(Encryption.hash(Encryption.increment(Crypto.converter.trits(seed.slice()))));

//  Merkle Tree attributes (explained later)
const start = 3;
const count = 4;    // Merkle Treeのsize
const security = 1;

//  Merkle Tree generation
const tree0 = new MerkleTree(seed, start, count, security);
const tree1 = new MerkleTree(seed, start + count, count, security);
let index = 0;

//  create bundle necessary for publishing your message to the Tangle.
const mam = new MAM.create({
    message: iota.utils.toTrytes(message),  // convert you raw message to trytes here.
    merkleTree: tree0,
    index: index,
    nextRoot: tree1.root.hash.toString(),
    channelKey: channelKey,
});

// Depth
const depth = 4;

// minWeighMagnitude
const minWeightMagnitude = 13;

console.log("Next Key: " + mam.nextKey);

// Send trytes（attach your Bundle to Tangle）
iota.api.sendTrytes(mam.trytes, depth, minWeightMagnitude, (err, tx) => {
  if (err)
    console.log(err);
  else
    console.log(tx);
});

```
## View message - getMessage.js
source [here](https://github.com/iotaledger/mam.client.js/blob/master/examples/getMessage.js).

```js:getMessage.js
const IOTA = require('iota.lib.js');
const MAM = require('../lib/mam');
const MerkleTree = require('../lib/merkle');
const Encryption = require('../lib/encryption');
var Crypto = require('iota.crypto.js');

const iota = new IOTA({
  provider: 'http://localhost:14600'
});

//  シード
const seed = 'PAUL9NOZTUVHPBKLTFVRJZTOPODGTYHRUIACDYDKRNAQMCUZGNWMDSDZMPWHKQINYFPYTIEDSZ9EJZYOD';
const channelKeyIndex = 3;

//  generating Channel Key of the channel you want to view.
//  When viewing someone else's channel, substitute given Channel Key here.
const channelKey = Crypto.converter.trytes(Encryption.hash(Encryption.increment(Crypto.converter.trits(seed.slice()))));

//  Merkle Tree attributes.
//  When viewing someone else's channel, substituting given root here.
//  explained later.
const start = 3;
const count = 4;    // size of Merkle Tree
const security = 1;

//  Merkle Tree generation
const tree0 = new MerkleTree(seed, start, count, security);

//  get the root
const root = tree0.root.hash.toString();



iota.api.sendCommand({
    command: "MAM.getMessage",
    channel: MAM.messageID(channelKey)
}, function(e, result) {
    if(e == undefined) {
        result.ixi.map(mam => {
            const output = MAM.parse({key: channelKey, message: mam.message, tag: mam.tag});
            const asciiMessage = iota.utils.fromTrytes(output.message);
            if (root === output.root) {
                console.log("Public key match for " + root);
            }
            console.log("received: " + asciiMessage);
        });

    }
});

```
# Behind MAM - Overview
## Channel Key - `channelKey`
　`chennelKey` is an arbitrary 81 trytes, like seed. First of all, publisher publish first `message`. The `message` is encrypted with the `channelKey`. In this way, no one other than this publisher can understand the `message`.

![mam_channelKey_basic.png](https://qiita-image-store.s3.amazonaws.com/0/187795/1459dbff-a02b-fc6c-bdb9-1caaa89844c7.png)

　However, in this way, you can only publish message once on your channel. In other words, one 'channelKey' can reach only one message. If you post new message on the channel, whenever you do so, you have to tell your viewer the new Channel Key. And you have to store all channel key safely and keep track of them which to which. It can be a mess.

## Image of Solution
　Let me explain to you with easy image for now. That might ignore small negligible details. (Don't worry for those with interests in minute detail, I will eventually explain.)
### Next Channel Key - `nextChannelKey`
　Before encrypting your raw message, MAM includes the **next channel key(`nextChannelKey`)** in your message to be encrypted. If to say in RPG, in the first treasure chest you opened, it's like you would find the key that opens next treasure chest. By repeating this can viewers sequently decrypt next `message` with `nextChannelKey` you obtained from current `message` you have just decrypted. And publisher can give `nextChannelKey` of any points on the channel. That way, you can restrict viewers from viewing the past messages.
 \*`nextChannelKey` can be arbitrary 81 trytes.

![mam_nextKey_1.png](https://qiita-image-store.s3.amazonaws.com/0/187795/035bba8e-d285-3a61-265d-f3fcf9e1b5fc.png)

### Address of the message - `messageID`
　You might have ever noticed, you have your key but don't have the map that guides you to the treasure chest. In technical term, having `channelKey` or `nextChannelKey` is no useful to find where the message is stored. 
 In MAM, the address the message is stored is called `messageID`. And it is simply generated by hashing `channelKey` or `nextChannelKey`. The map is drawn on the key. Just having your key is suffucient for both finding and decrpting message.

![mam_messageID1.png](https://qiita-image-store.s3.amazonaws.com/0/187795/24322eb3-93d4-b82e-2afd-4d9fd58ae6eb.png)

\* The way to generate `messageID` is arbitrary as long as you and potential viewers share how to. But, at least you should hash it to protect your key.

### Message Chain
　The genesis `message` that contains raw message and `nextChannelKey` of the channel encrypted with `channelKey` will be a part of the bundle. And the bundle that contain next `message` is pointed by the previous bundle. By repeating this, you can now see a chain on the Tangle, **Message Chain**. You can join message chain at any points with corresponding key to decrypt it, but never can go back to see past posts.

## Implimentaion in Practice
　さて、今までは絵を使って説明してきたが、ここで実際のMAMの話をしよう。
　まず、メッセージチェーンを過去から最新の投稿へ辿る際にいちいち`message`を鍵で復号するのは計算コストが高い。もし、100個投稿したチャンネルの最新記事まで最初から辿っていくとなると膨大な計算量が必要になる。そのため実装では`nextChennelKey`は、任意に決めて`message`に含ませるのではなく、`nextChannelKey = hash(channelKey + salt)`という式で生成できるようにしている。`salt`というのは投稿する時にTransactionオブジェクトの`tag`に入れる値である。
　その`tag`の値を知るには`messageID`が必要だ。`channelKey`からしか`messageID`を見つけられないので、結果的に`channelKey`を知る人しか`nextChannelKey`を知ることができないという機能を保持したまま、最新の投稿に辿り着くコストを低く抑えられる。

　宝箱の例えで言うなら「次の宝箱を開けるnext鍵を宝箱の中に入れるのではなく、宝箱の裏にでも貼り付けておくようなものだ。しかも、たまたま宝箱の前を通りかかった人にはそのnext鍵は見えない。見えるのはその宝箱を開ける鍵を持ってきた人だけ。」という感じだろうか。

![mam_next_key_tx.png](https://qiita-image-store.s3.amazonaws.com/0/187795/af4df8f3-9a12-e897-4d47-a247be596586.png)

　また、`message`が`sigF`の限界2187トライトより長くなったとしても投稿を二回に分ける必要はない。[Bundleの全容](https://qiita.com/ABmushi/items/0c9f73e08fdb6597ab9c#bundle%E3%81%AE%E6%A7%8B%E9%80%A0)でも軽く触れたが、`message`が長くなった分、Bundle内のTransactionを増やせば、どんな長さのトライトも一度に一つのBundleにまとめて投稿できる。ただ、容量の大きなBundleはTangleに貼り付けるためのPoWがその分大きくなりコスパはよくないうえ読み込むのにも時間がかかるが。

# MAMの裏側 - 投稿
　さて、今までざっくり説明した中で語られなかったチャンネルの所有権（投稿権）についての話をしたい。なぜそんな話をするかは、次のようなケースを考えると分かるかもしれない。

　チャンネルに初投稿したAさんはBさんにチャンネルを見て欲しいと考えた。そこで、AさんはBさんにチャンネル鍵を教えた。BさんはAさんにもらった`channelKey`で`messageID`を訪れ、`message`を復号しAさんの投稿を閲覧した。続きが気になったBさんは復号の際手に入った`nextChannelKey`で次の`messageID`（=アドレス）を生成し、次の`message`を見ることにした。しかし、Aさんはまだ次の投稿をしていなかったので、その`messageID`宛てにはまだ何のトランザクションも発行されていなかった。
　BさんはAさんに嫌がらせをしたいと突然思いついた。見渡すとBさんの手には、`nextChannelKey`と次の`messageID`があった。これがあれば、Bさんは次の`message`をBさんが勝手に決めて、`nextChannelKey`で暗号化してこの`messageID`宛てにAさんより先に投稿すれば、Aさんのチャンネルを乗っ取れると考えた。
　これは上手くいくだろうか？上記MAMの表側で説明した原理を元にすれば上手くいくように思える。
...しかし、それではMAMは失敗だ。もちろんこのようなことが起こらないためにMAMは設計されている。この章では、そんなチャンネルの所有権をどう確保するかという話をする。

## チャンネルの所有権問題
　さて、上の問題点を簡潔に述べると**Chaneel Keyの実装だけでは、AさんとBさんどちらがチャンネルの所有者か分からない**ということだ。
　ここでIOTAにおける、アドレスの残高の所有権はどう証明したかを思い出してみよう。アドレスの残高を引き出す際には、Seedから生成される**Private Key**で[署名](https://qiita.com/ABmushi/items/422d1bf94be0c919583a#%E7%BD%B2%E5%90%8D%E3%81%AE%E6%96%B9%E6%B3%95)したトランザクションが承認されることで残高を引き出すことができた。
　MAMではPrivate KeyをMerkle Treeと組み合わせることでチャンネルの所有権を証明するのに利用する。

## Merkle tree based signature scheme 
　MAMにおける**Merkle Tree（マークル木）**を使った独特な署名方法について説明をしたい。[Merkle tree based signature scheme](https://www.imperialviolet.org/2013/07/18/hashsig.html)と言う技術らしいので興味ある人はリンク先を読んで見ると良い。
　また、Merkle Treeというコンピューターサイエンスの専門用語についての解説は省略させていただく。というのも、Merkle Treeは暗号通貨界御用達の技術であり、ビットコイン価格の高騰とともに解説記事も爆発的に増えたため、わざわざここで説明し直す必要がないと判断したからだ。

### Merkle Treeの生成
[ソースコード](https://github.com/iotaledger/mam.client.js/blob/master/lib/merkle.js#L54)
　MAMのMerkle TreeはSeedから生成する。（種が木へ！）Merkle Treeは`start`と`size`という引数をとる。これはSeedから生成されうる`address`の[連鎖](https://iotafan.jp/developer/iota_universe_abmushi_20171213/)のどの部分をMerkle Treeの葉として使うかに用いられる。SeedからPrivate Keyを生成し、`address`を生成するために、`index`という引数をとったことを覚えているだろうか？（忘れてしまった人のための記事は[こちら](https://qiita.com/ABmushi/items/e271ff05884a7d47658d#%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9)。）下の図のA、B、C、Dはそれぞれ`index`が0~3で生成されるPrivate Keyだ。A'、B'、C'、D'は該当Private Keyから生成される`address`である。
![mam_merkle_1-2.png](https://qiita-image-store.s3.amazonaws.com/0/187795/06ea21b7-6427-90b4-1c82-4a64c53a0df1.png)
　Merkle Treeの葉A"、B"、C"、D"には`address`にハッシュ関数を通したものを用いる。葉から`root`へ枝が根に集まるようにハッシュ関数に通していく。図で言うと下のノードから葉の方向へ逆生成させることはできない。

### Siblingsの取得
　Siblings（兄弟）という概念について説明する。
　まず、上のMerkle Tree上の葉`A'`が与えられたとする。`root`を得るためには全ての葉`B'C'D'`が必要になるが全ての葉を知れない場合どうやって`root`を導き出せるか。Siblingsとは葉`A'`とともに`root`を得るために使われるMerkle Tree上の枝のことである。図を見る方が早いかも知れない。
![mam_2_siblings_2.png](https://qiita-image-store.s3.amazonaws.com/0/187795/c3f7d1b4-984b-d4a1-d054-e788fe2a7a10.png)

　今回の例では葉`A'`が与えられた。その場合は`B"`と`Hash(C"D")`があれば**全ての葉を知らなくとも`root`を求めることができる**。このような関係を持つ枝、`B"`と`Hash(C"D")`を`A'`の**Siblings**と呼ぶ。

### 秘密鍵と公開鍵
　署名主が隠したい秘密鍵は今回の場合、Private KeyのA、B、C、Dのペアだ。Seed所有者だけが秘密鍵を持っている。（Private KeyはSeedと同様他人に教えてはダメだ。）そして、署名の公開鍵はA、B、C、Dから生成される`root`と`siblings`である。
　`siblings`から`root`を生成できるのはMerkle Treeを生成した本人だけである。本人以外は`siblings`だけでは足りず、欠けた部分を補う葉が必要だ。
　上の例で考えるなら`index=0`の`siblings=[B",Hash(C"D")]`を与えられた場合、`A'`を持っていないと`root`を生成できない。`A'`は本人しか持っていない。つまり、公開されている情報は`siblings`だけなのに`root`を生成できることが本人であることの証明になる。*※重要なのは`root`を知ることではなく生成できることだ。*
　![mam_2_merkle_pubkey.png](https://qiita-image-store.s3.amazonaws.com/0/187795/42e5b069-c3bf-333e-2d9f-84b7fa916bcb.png)
　
　この仕組みを使ってMAMではチャンネルの本人識別を実現した。さて、次章でついにその本題に入ろう。

# MAMの裏側 - 署名・承認
　ここまで記事で出てきた大きな概念が二つあった。
>1. nextChennelKeyで繋がるメッセージチェーン
>2. Merkle Tree

　この二つを組み合わせてMAMの投稿は成し遂げられる。この章ではついにMAMの実際行われているメッセージ生成の手順を説明していく。
## MAMメッセージの生成 - MAM.create
[ソースコード](https://github.com/iotaledger/mam.client.js/blob/master/lib/mam.js#L63)
　まず、Aさんが初めてチャンネルを開設する際、Aさんは
>1. `channelKey`を一つ生成。
2. 同じ`size`のMerkle Treeを`start`から２つ分生成。

　Merkle Tree２つだが、どちらとも*Merkle Treeの生成*で説明した方法で作成する。１つ目`tree0`は`start0 = start`、`size0 = size`。２つ目`tree1`は`start1 = start0+size0`、`size1 = size0`。言い換えると生成されるPrivate Keyの連鎖で１つ目のMerkle Treeが使っていない次の部分を使う。下図参考。
![mam_2_double_merkle.png](https://qiita-image-store.s3.amazonaws.com/0/187795/67d5fc56-b28f-4d91-65c5-9a56b416d240.png)
　MAM投稿の時、こうして生成された２つのMerkle Treeのうち`tree0`の木丸ごとと`tree1`の`root`（**nextRoot**）を引数にとる。また、**葉番号**という値を**0以上size未満**から選ぶ。今回は分かりやすく`leaf_index = 0`としよう。**葉番号**はMerkle Treeの葉の一番左から何番目を示す。`tree0`の葉番号0は`A'`、`tree1`の葉番号2は`G'`である。

```java:MAM.createの例
leaf_index = 0    // 葉番号

const mam = new MAM.create({
    message: iota.utils.toTrytes(message),  // messageをトライトに変換
    merkleTree: tree0,                      // １つ目のMerkle Tree
    index: leaf_index,                      // 葉番号
    nextRoot: tree1.root.hash.toString(),   // 次のroot。上図のroot_1。
    channelKey: channelKey,                 // ChannelKey（このメッセージの暗号化に使われる。）
});
```
　`MAM.create`の中で行われることを次に説明する。
　まず、`tree0`の**Siblings**を求める。今回与えられる葉は先ほど決めた**葉番号**の葉とする。ということは`leaf_index = 0`なので`siblings`は`B"`と`Hash(C"D")`になる。
![mam_2_small_sib.png](https://qiita-image-store.s3.amazonaws.com/0/187795/d67e16e9-7ad9-d54e-4ba6-978af070fc0d.png)
　次に、`messageTrytes`と呼ばれる**「nextRootと平文を足した文字列」**を署名されるデータとして**葉番号のPrivate Key**で署名を作る。署名作成については[こちら](https://qiita.com/ABmushi/items/422d1bf94be0c919583a#%E7%BD%B2%E5%90%8D%E3%81%AE%E6%96%B9%E6%B3%95)でも説明したが、それを踏まえて下図のように署名は作られる。
![mam_2_sig2.png](https://qiita-image-store.s3.amazonaws.com/0/187795/5c4af53b-d673-6e3b-b71b-ee9778df1335.png)
　こうして今、手元にある値を使ってMAMの１つのメッセージは作られる。それを図示すると下のようになる。
![mam_2_overview_single.png](https://qiita-image-store.s3.amazonaws.com/0/187795/bc220ff5-85ff-8cfe-2fac-0cadf57b32d1.png)
## MAMメッセージ閲覧 - MAM.parse
[ソースコード](https://github.com/iotaledger/mam.client.js/blob/master/lib/mam.js#L131)
　次に投稿されたメッセージを閲覧する方法について説明する。これを読むことで今まで出てきた話がついに一つにまとまる。
### チャンネル鍵と**root**を閲覧者に教える
>**チャンネル鍵**はメッセージの復号のための鍵、`messageID`（アドレス）として閲覧者に教える。そして、メッセージがAさんのものだと照らし合わせるための勘合として**`root`**を閲覧者に渡す。

　この例だと、チャンネル鍵と`tree0`の`root_0`を閲覧者にチャンネル鍵として渡す。ここでBさんが閲覧者としてAさんからチャンネル鍵とrootを教えてもらったとしよう。
　Bさんはチャンネル鍵からメッセージの保管アドレス`messageID`を作ってメッセージを見つける。そして、チャンネル鍵でメッセージを復号する。
　次に、復号したメッセージの署名を`messageTrytes`（署名されるデータ）で承認する。署名の承認の仕方は[こちら](https://qiita.com/ABmushi/items/422d1bf94be0c919583a#%E6%89%BF%E8%AA%8D%E3%81%AE%E6%96%B9%E6%B3%95%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%81%AE%E9%80%86%E7%94%9F%E6%88%90)。

　![mam_2_sig_address.png](https://qiita-image-store.s3.amazonaws.com/0/187795/464abb92-1775-8faa-8870-bf8e86fe2df9.png)
### 本人のメッセージか検証
　次に、承認して得られたアドレスが`leaf_index`の場所のアドレスとして`Siblings`を使ってその`root`を求める。こうして求められた`root`（下図のroot_0）がAさんからもらった`root`と一致すれば、メッセージはAさんのものだと閲覧者は判断できる。
![mam_2_address_merkle.png](https://qiita-image-store.s3.amazonaws.com/0/187795/052d06e5-640a-6c12-5467-df1751d0a1db.png)
　そうでない場合はどういうことか。署名を承認する時に使う`messageTrytes`の内容がAさんが作ったものと違う場合、得られるアドレスが変わる。そのアドレスと`Siblings`を使ってrootを求めると、もちろん得られる`root`の値も変わる。そして、Aさんから教えてもらった`root`と一致しない。
　こうすることで、もし悪意ある者がチャンネル鍵を使って同じ`messageID`（アドレス）宛に全くAさんと関係のないメッセージを投稿したとしても、このrootの検証作業で最終的に弾かれる。

## メッセージチェーンの構築 - nextRoot
　MAMはメッセージチェーンだ。一つのメッセージを復号すれば、`nextChannelKey`を使って次のメッセージも閲覧できる。ということは、その次のメッセージがチャンネル所有者本人が投稿したものか検証する必要がある。そのため、メッセージには`nextChannelKey`の他に、`nextRoot`という値も含ませる。この`nextRoot`は`messageTrytes`に平文と一緒に含まれているため署名されるデータの一部である。`nextRoot`生成するたびに、上の図で言う所のMerkle rootの生成に使われる葉（ABCDEF...）が右にどんどんずれていく。（`start`が大きくなっていく。）
　次の投稿を`nextChannelKey`で復号した際には、前項で説明したように今度は`nextRoot`と最終的に得られる`root`と一致するかを確認する。

## 小休止
　理解できただろうか？想像以上に多くのアイデアが詰め込まれていたことに驚いたかもしれない。筆者も文でうまく説明できたか不安だ。
　不明点等あれば公式Slackで筆者@abmushi宛にDMでもチャットでも良いので質問をじゃんじゃん投げて欲しい。質疑応答はお互いの理解が深まる絶好のチャンスだ。

# チェーンフォーク - 分裂
　最後にMAMを特徴づける**分裂**という機能についても説明したい。ブロックチェーンのようにメッセージチェーンもフォークする。
　メッセージを分裂させたいときは、単純に葉番号`leaf_index`が違う`siblings`を含むメッセージを投稿すれば良い。こうすることで同じ`messageID`（アドレス）に本人検証も問題なくできるメッセージを複数（最大はMerkle Treeの`size`）持てる。
　また、`nextChannelKey`の生成方法も（nextChannelKey=hash(channelKey,leaf_index)）というように`leaf_index`に依存するようにすれば、フォーク後全く違うアドレスを辿るようにチェーンを伸びていかせることもできる。

## 利用例
　筆者が思いついたこのチェーンフォークの用途は、MAMのメッセージチェーン自体をディレクトリのツリー構造として利用すること。
　まず最初にルートディレクトリを投稿する。そのディレクトリの子ディレクトリの数だけ分裂させることを繰り返せば、Tangle上にツリー構造を作れる。また、どの部分のチャンネル鍵を教えるかによってファイルのアクセス権限も持たせることができる。

# MAMとはプロトコル
　MAMとはそれ自体が発行者が自由に決められるプロトコルである。投稿者と潜在的な閲覧者の間でMAMの各種値（`nextChannelKey`、`messageID`、や`nextRoom`）の計算方法を統一することで、この記事で紹介した方法以外の手順を使ってMAMを発行できる。

# 最後に
　MAMを理解したいという気持ちはずっと持っていたものの、今IOTAが取り組んでいる課題は別のところにあり、コミュニティで具体的にはほとんど語られず、ビジョンとしてのみ存在していたこのMAM。結局公式のソースコードを読んで自分で理解するしか手段がなかった。
　その結果、IOTAのBundleや署名などの根幹技術がコードレベルでどうなっているか理解できたので結果的にはものすごくためになった。
　記事中でも今まで投稿したIOTAの記事の知識が前提になることが多く数え切れないほど引用リンクを貼った。間違いなくこの記事は今年の集大成だろう。
　それではみなさん良いお年を！

# 参考文献
JSのコード：[mam.client.js](https://github.com/iotaledger/mam.client.js)
公式アナウンス：[Introducing Masked Authenticated Messaging](https://blog.iota.org/introducing-masked-authenticated-messaging-e55c1822d50e)
外観：[Overview](https://github.com/iotaledger/mam.client.js/blob/master/Overview.md)
たまたま見つけた中国語の記事：[MAM　筆記](https://hackmd.io/c/rkpoORY4W/%2Fs%2FrJkpIrrbM)
